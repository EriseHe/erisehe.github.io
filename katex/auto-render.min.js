(function (e, t) {
    if (typeof exports === "object" && typeof module === "object") {
        module.exports = t(require("katex"));
    } else if (typeof define === "function" && define.amd) {
        define(["katex"], t);
    } else if (typeof exports === "object") {
        exports.renderMathInElement = t(require("katex"));
    } else {
        e.renderMathInElement = t(e.katex);
    }
})(
    typeof self !== "undefined" ? self : this,
    function (e) {
        "use strict";

        var modules = {
            771: function (module) {
                module.exports = e;
            }
        };

        var cache = {};

        function requireModule(moduleId) {
            if (cache[moduleId] !== undefined) return cache[moduleId].exports;

            var module = (cache[moduleId] = {
                exports: {}
            });

            modules[moduleId](module, module.exports, requireModule);
            return module.exports;
        }

        requireModule.n = function (module) {
            var getter = module && module.__esModule 
                ? function () { return module.default; } 
                : function () { return module; };
            requireModule.d(getter, { a: getter });
            return getter;
        };

        requireModule.d = function (module, definition) {
            for (var key in definition) {
                if (requireModule.o(definition, key) && !requireModule.o(module, key)) {
                    Object.defineProperty(module, key, {
                        enumerable: true,
                        get: definition[key]
                    });
                }
            }
        };

        requireModule.o = function (obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        };

        var output = {};

        (function () {
            requireModule.d(output, { default: function () { return renderMathInElement; } });

            var katex = requireModule(771);
            var katexInstance = requireModule.n(katex);

            const findEndDelimiter = function (startDelimiter, content, startIndex) {
                let index = startIndex;
                let depth = 0;
                const len = startDelimiter.length;

                while (index < content.length) {
                    const char = content[index];
                    if (depth <= 0 && content.slice(index, index + len) === startDelimiter) return index;

                    if (char === "\\") index++;
                    else if (char === "{") depth++;
                    else if (char === "}") depth--;
                    
                    index++;
                }
                return -1;
            };

            const beginRegex = /^\\begin{/;

            var parseContent = function (content, delimiters) {
                let match;
                const elements = [];
                const delimiterRegex = new RegExp(
                    "(" + delimiters.map(delim => delim.left.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")).join("|") + ")"
                );

                while ((match = content.search(delimiterRegex)) !== -1) {
                    if (match > 0) {
                        elements.push({ type: "text", data: content.slice(0, match) });
                        content = content.slice(match);
                    }

                    const delimiterIndex = delimiters.findIndex(delim => content.startsWith(delim.left));
                    const endIndex = findEndDelimiter(delimiters[delimiterIndex].right, content, delimiters[delimiterIndex].left.length);

                    if (endIndex === -1) break;

                    const rawData = content.slice(0, endIndex + delimiters[delimiterIndex].right.length);
                    const data = beginRegex.test(rawData) 
                        ? rawData 
                        : content.slice(delimiters[delimiterIndex].left.length, endIndex);

                    elements.push({
                        type: "math",
                        data: data,
                        rawData: rawData,
                        display: delimiters[delimiterIndex].display
                    });

                    content = content.slice(endIndex + delimiters[delimiterIndex].right.length);
                }

                if (content !== "") {
                    elements.push({ type: "text", data: content });
                }

                return elements;
            };

            const renderMathContent = function (content, options) {
                const elements = parseContent(content, options.delimiters);

                if (elements.length === 1 && elements[0].type === "text") return null;

                const fragment = document.createDocumentFragment();

                elements.forEach(element => {
                    if (element.type === "text") {
                        fragment.appendChild(document.createTextNode(element.data));
                    } else {
                        const span = document.createElement("span");
                        let data = element.data;

                        options.displayMode = element.display;

                        try {
                            if (options.preProcess) data = options.preProcess(data);
                            katexInstance().render(data, span, options);
                        } catch (error) {
                            if (!(error instanceof katexInstance().ParseError)) throw error;
                            options.errorCallback(`KaTeX auto-render: Failed to parse \`${element.data}\` with`, error);
                            fragment.appendChild(document.createTextNode(element.rawData));
                            return;
                        }

                        fragment.appendChild(span);
                    }
                });

                return fragment;
            };

            const processNodes = function (element, options) {
                for (let i = 0; i < element.childNodes.length; i++) {
                    const childNode = element.childNodes[i];

                    if (childNode.nodeType === 3) {
                        let textContent = childNode.textContent;
                        let sibling = childNode.nextSibling;
                        let extraNodes = 0;

                        while (sibling && sibling.nodeType === Node.TEXT_NODE) {
                            textContent += sibling.textContent;
                            sibling = sibling.nextSibling;
                            extraNodes++;
                        }

                        const mathContent = renderMathContent(textContent, options);

                        if (mathContent) {
                            for (let j = 0; j < extraNodes; j++) {
                                childNode.nextSibling.remove();
                            }
                            i += mathContent.childNodes.length - 1;
                            element.replaceChild(mathContent, childNode);
                        } else {
                            i += extraNodes;
                        }

                    } else if (childNode.nodeType === 1) {
                        const classList = ` ${childNode.className} `;
                        if (
                            options.ignoredTags.indexOf(childNode.nodeName.toLowerCase()) === -1 &&
                            options.ignoredClasses.every(cls => classList.indexOf(` ${cls} `) === -1)
                        ) {
                            processNodes(childNode, options);
                        }
                    }
                }
            };

            var renderMathInElement = function (element, options) {
                if (!element) throw new Error("No element provided to render");

                const config = { ...options };

                config.delimiters = config.delimiters || [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false },
                    { left: "\\begin{equation}", right: "\\end{equation}", display: true },
                    { left: "\\begin{align}", right: "\\end{align}", display: false },
                    { left: "\\begin{aligned}", right: "\\end{aligned}", display: false },
                    { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
                    { left: "\\begin{gather}", right: "\\end{gather}", display: true },
                    { left: "\\begin{CD}", right: "\\end{CD}", display: true },
                    { left: "\\[", right: "\\]", display: true }
                ];

                config.ignoredTags = config.ignoredTags || ["script", "noscript", "style", "textarea", "pre", "code", "option"];
                config.ignoredClasses = config.ignoredClasses || [];
                config.errorCallback = config.errorCallback || console.error;
                config.macros = config.macros || {};

                processNodes(element, config);
            };
        })();

        return output.default;
    }
);